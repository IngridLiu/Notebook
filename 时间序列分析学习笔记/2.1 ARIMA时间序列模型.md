# ARIMA时间序列模型

## 1. ARIMA 时间序列模型介绍

&emsp;&emsp;经典的时间序列模型包括移动平均模型（Moving Average，MA）、自回归模型（Auto Regressive，AR）、自回归移动平均模型（Auto Regressive Moving Average，ARMA）。假设x_t表示t时刻的时间序列的值，p和q表示时间窗的大小，ε_t表示t时刻的白噪声，α_1,…,α_p和β_1,…,β_q表示权重系数。

&emsp;&emsp;AR(p)表示为：

![](https://upload-images.jianshu.io/upload_images/10947003-a1473ca3666ba125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200)

&emsp;&emsp;MA(q)表示为：

![](https://upload-images.jianshu.io/upload_images/10947003-ae0cb30bb1678bde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200)

&emsp;&emsp;ARMA(p,q)分别表示为：

![](https://upload-images.jianshu.io/upload_images/10947003-9dc20c2176de80f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200)

&emsp;&emsp;下面的图表说明了AR系列的惯性特征：

![](https://upload-images.jianshu.io/upload_images/10947003-044be34937f700f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

&emsp;&emsp;MA：

![](https://upload-images.jianshu.io/upload_images/10947003-8ccc170f3ac3fb63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

### 1.2 AR模型与MA模型的不同

&emsp;&emsp;AR和MA模型之间的主要区别是基于不同时间点的时间序列对象之间的相关性。x（t）与x（t-n）的相关性总为0，这直接源于x(t)和x(t-n)之间的协方差对于MA模型来说是零。然而，MA模型中x(t)和x(t-n)的相关性总为0，这直接源于x(t)和x(t-n)之间的协方差对于MA模型来说是零。然而，MA模型中x(t)和x(t-1)的相关性随着时间的推移变得越来越小。不管是否有AR模型或MA模型，这种差异都可以被利用。

<br>

## 2. ARIMA模型实现

&emsp;&emsp;实现ARIMA模型的通用步骤如下：

> 1. 加载数据
> 2. 预处理：创建时间戳，日期/时间类型转换为d类型，序列单变量化。
> 3. 序列平稳化
> 4. 确定d值
> 5. 创建ACF和PACF图
> 6. 确定p值和q值
> 7. 拟合ARIMA模型
> 8. 在验证集上进行预测
> 9. 计算RMSE

&emsp;&emsp;ARIMA模型可使用statsmodels中的ARIMA模型实现：

&emsp;&emsp;模型参数及方法：

```python3
from statsmodels.tsa.arima_model import ARIMA

ARIMA(endog, order, exog=None, dates=None, freq=None, missing='none')
"""
    params:
        endog (array-like) – The endogenous variable.
        order (iterable) – The (p,d,q) order of the model for the number of AR parameters, differences, and MA parameters to use.
        exog (array-like, optional) – An optional array of exogenous variables. This should not include a constant or trend. You can specify this in the fit method.
        dates (array-like of datetime, optional) – An array-like object of datetime objects. If a pandas object is given for endog or exog, it is assumed to have a DateIndex.
        freq (str, optional) – The frequency of the time-series. A Pandas offset or ‘B’, ‘D’, ‘W’, ‘M’, ‘A’, or ‘Q’. This is optional if dates are given.
    returns Model
"""

# methods：

fit(params)	# Fits ARIMA(p,d,q) model by exact maximum likelihood via Kalman filter.
from_formula(params)	# Create a Model from a formula and dataframe.
geterrors(params)	# Get the errors of the ARMA process.
hessian(params) # Compute the Hessian at params,
information(params)	# Fisher information matrix of model
initialize(params)	# Initialize (possibly re-initialize) a Model instance.
loglike(params)	# Compute the log-likelihood for ARMA(p,q) model
loglike_css(params)	# Conditional Sum of Squares likelihood function.
loglike_kalman(params)	# Compute exact loglikelihood for ARMA(p,q) model by the Kalman Filter.
predict(params)	# ARIMA model in-sample and out-of-sample prediction
score(params)	# Compute the score function at params.

# values
result = model.fit().fittedvalues
```

&emsp;&emsp;ARIMA的python实现：

```python3
from statsmodels.tsa.arima_model import ARIMA
# 训练模型
# AR模型
model = ARIMA(ts_log, order = (0, 1, 0))  # p=0
results_AR = model.fit(disp = -1)
resulrs_AR.fittedvalues
# MA模型
model = ARIMA(ts_log, order = (0, 1, 1))    # q=1
result_MA = model.fit(disp = -1)
results_MA.fittedvalues
# ARIMA模型
model = ARIMA(ts_log, order = (0, 1, 1))    # p=0, q=1
result_MA = model.fit(disp = -1)
results_MA.fittedvalues

# 预测结果
predictions_ARIMA = model.predict(start='1950-01-01', end='1962-04-01')
```

&emsp;&emsp;经过ARIMA对数据预测后，需将数据还原到原数据空间。

<br>

## 2. Auto ARIMA

ARIMA需要非常繁琐的数据预处理和调参步骤，而AUTO ARIMA只需要下面几步：

> 1. 加载数据
> 2. 预处理数据
> 3. 拟合AUTO ARIMA
> 4. 在验证集上进行预测
> 5. 计算RMSE

AUTO ARIMA的实现：

```python3
from pyramid.arima import auto_arima

data = df.sort_index(ascending=True, axis=0)
train = data[:987]
valid = data[987:]

training = train['Close']
validation = valid['Close']

model = auto_arima(training, start_p=1, start_q=1,max_p=3, max_q=3, m=12,start_P=0, seasonal=True,d=1, D=1, trace=True,error_action='ignore',suppress_warnings=True)
model.fit(training)

forecast = model.predict(n_periods=248)
forecast = pd.DataFrame(forecast,index = valid.index,columns=['Prediction'])

rms=np.sqrt(np.mean(np.power((np.array(valid['Close'])-np.array(forecast['Prediction'])),2)))
#plot
plt.plot(train['Close'])
plt.plot(valid['Close'])
plt.plot(forecast['Prediction'])
```

<br>
<br>
<br>
<br>

## Reference:

1. [时间序列预测初学者入门指南（Python）](https://github.com/IngridLiu/Notebook/blob/master/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E5%88%9D%E5%AD%A6%E8%80%85%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%88Python%EF%BC%89.md)

2. [独家 | 利用Auto ARIMA构建高性能时间序列模型（附Python和R代码）](https://mp.weixin.qq.com/s/ypfARPWCXpNgZ5CmTuxO_g)