# 基于树表示法的变邻域搜索算法求解考虑后进先出的取派货旅行商问题

<br>
<br>
<br>

## 1 什么是考虑后进先出的取派货旅行商问题？（the Pickup and Delivery Traveling Salesman Problem with LIFO Loading）

&emsp;&emsp;考虑后进先出的取派货旅行商问题是旅行商问题的一个变种，它可以描述为：假设车辆从起点（depot）出发去完成所有任务，每个任务分别对应着一个位于不同地理位置的取货点和派货点,需要制定一条路线来保证总费用最小。其中，从起点出发提供服务的车辆只有一辆；车辆必须先到达取货点获得货物才能去派货点；车辆装卸货时必须服从后进先出原则。要处理现实情况中的问题，首先要将其转化为对应的数学模型，然后研究模型，对所建立的模型进行求解。

&emsp;&emsp;给出的完全无向连通图G=(V,E,d)中，点的集合表示为V=P∪D∪{0+,0-},边的集合表示为E={(x,y):x≠y∈V}，d(x,y)表示点x和点y之间的距离。其中点0+和点0-表示起点，P={1+,...,n+}表示取货点集合，D={1-,...,n-}表示送货点集合。车辆的速度为单位速度（即从点x到点y的时间在数值上与其欧式距离dij相等）。车辆必须从位置0+开始并回到位置0-。车辆装卸货时必须服从后进先出原则。

<br>

## 2 使用树表示法的变邻域搜索算法求解考虑后进先出的取派货旅行商问题

&emsp;&emsp;旅行商问题中解的编码方式一般采用自然数编码并使用数组进行存储，如下图所示。此种存储结构的优点是清晰易懂且解码过程简单，但在进行移动或遍历等操作时具有时间复杂度高的缺点（即操作耗时多）。

![](https://upload-images.jianshu.io/upload_images/10947003-741970e663ead3c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

&emsp;&emsp;本文采用树结构来存储解，如下图（a）所示。此种存储结构虽然看起来有些繁琐难懂，但是便于进行移动和遍历操作。解码过程如下图（b）所示，即从顶点0处对树中叶子节点进行遍历和递归。将树转换为可行解及其逆过程的算法复杂度仅为O(n),其中n是节点的个数（即线性时间）。

&emsp;&emsp;与数组存储方式相比，树表示法主要有以下优点：

&emsp;&emsp;1)节点序列表示的解与树表示的解释呈一一对应的关系，树形结构可以自动保证解的可行性，而节点序列表示的解不一定是可行解；

&emsp;&emsp;2)基于树形表示方式，在用算子进行操作时不需要检验新生成解的可行性，节省计算时间；

&emsp;&emsp;3)如果用节点序列来表示解，一旦采用交换节点的邻域搜索算子，生成的新解极有可能违反先进后出的约束；

&emsp;&emsp;4)基于树形表示方式的算子实现过程简单且更直接，大量与树相关的算子可以被使用。

![](https://upload-images.jianshu.io/upload_images/10947003-a9ede6834040cb15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

![](https://upload-images.jianshu.io/upload_images/10947003-be0fbdaf72dfbd15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

&emsp;&emsp;TSP问题是经典的NP完全问题。精确的解决TSP问题的算法复杂度为O(2^n), 其中n是节点的个数。而TSPPDL在基础的TSP问题上加了约束，其复杂度远远高于原问题。



<br>

## 3 算法步骤

### 3.1 伪代码：

![伪代码](https://upload-images.jianshu.io/upload_images/10947003-7cb5688bdd168903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

### 3.2 算法步骤

&emsp;&emsp;算法的主要步骤为：

&emsp;&emsp;1)步骤1，设置最大迭代次数max_iter、最大无改进迭代次数max_nonimproving、种群大小pop_size等参数；

&emsp;&emsp;2)步骤2，新建大小为pop_size的种群population（即新建大小为pop_size的数组）；

&emsp;&emsp;3)步骤3，初始化当前最好解S_best；步骤6-8，初始化种群population（即将个体S_best执行pop_size次扰动操作）；

&emsp;&emsp;4)步骤10-18，对种群population的每个个体使用局部搜索算子、ATSP算子、交叉算子crossover进行搜索（具体算子描述见下文）；

&emsp;&emsp;5)函数local_search()使用了5种邻域搜索算子，就是前文提到的Variable neighborhood Descent阶段；

&emsp;&emsp;6)步骤19-24，更新当前解S_current和全局最好解S_best；

&emsp;&emsp;7)步骤25-27，对种群population使用扰动算子perturbation进行一定的扰动（具体算子描述见下文）。


&emsp;&emsp;其中，函数local_search()共采用5种搜索算子：

1. 子树移位算子：

&emsp;&emsp;随机删除原树中的一棵子树，遍历插入到树中的任意节点下，邻域为所有子树移位可能得到的解的集合。如下图所示，图（a）、（b）分别为初始解和经过子树移位后的解。

![](https://upload-images.jianshu.io/upload_images/10947003-90888c7056a36d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)


2. 子树交换算子：

&emsp;&emsp;随机选择原树中的两棵子树并交换他们的位置。邻域为子树交换算子完全遍历能得到的解的集合。如下图所示，图（a）、（b）分别为初始解和经过子树交换后的解。

![](https://upload-images.jianshu.io/upload_images/10947003-c8cbe83319749509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

3.节点移位算子：

&emsp;&emsp;随机删除原树中的一个节点，遍历插入到树中的任意节点下。邻域为节点移位算子完全遍历能得到的解的集合。如下图所示，图（a）为初始解，删除节点x后将其作为节点0的子节点可以有4种情况，即如图(c),(d),(e)和(f)。

![image.png](https://upload-images.jianshu.io/upload_images/10947003-be903635ce0c8690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)







